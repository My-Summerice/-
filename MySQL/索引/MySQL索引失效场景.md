## MySQL索引失效场景

[toc]

#### 1. 对索引使用带左模糊匹配的查询

![image-20240126184940828](C:\Users\Summerice\AppData\Roaming\Typora\typora-user-images\image-20240126184940828.png)

​	type = ALL 代表没走索引，进行了扫表查询。

原因：

​	MySQL 默认使用的是 InnoDB 存储引擎，而该存储引擎使用的是 B+Tree 作为索引的数据结构，而 B+Tree 在存储数据时是**有序排列存储**的，也就是说每次查询时都会把条件中的值从左往右一个一个跟 B+Tree 中的节点值进行比较大小，而此时，你要是使用了左模糊匹配，就没办法比大小了，只能通过扫表的方式查出需要的数据。

​	**特殊的：**当数据库**只有自增主键和某个二级索引两个字段时，即使使用带左模糊匹配的查询条件也不会走全表查询**，这是因为只有两个字段时，二级索引的B+Tree上就已经包含了整张表的所有数据，且因为聚簇索引会存储一些额外信息，比如事务id、回滚指针等，所以在这种情况下 MySQL 查询优化器认为直接遍历二级索引树是效率最高的方案，所以选择了这种方式。

#### 2.对索引使用函数

![image-20240129152337787](C:\Users\Summerice\AppData\Roaming\Typora\typora-user-images\image-20240129152337787.png)

原因：

​	索引中存储的是具体字段的值，而不是经过函数计算后的值，所以在这种情况下也是会进行扫表先将该字段所有的值拿出来，才依次计算进行匹配从而拿到查询结果的。

但是：

​	从 MySQL 8.0 开始，索引特性更新，现在可以创建一个函数计算作为索引，而再次使用这个函数时就可以走索引了。比如：

```mysql
alter table user add key idx_name_length ((length(name)));
```

这样操作后 length(name) 就变为了一个新的索引。

![image-20240129153618678](C:\Users\Summerice\AppData\Roaming\Typora\typora-user-images\image-20240129153618678.png)

可以看到给该函数加了索引后同样的查询语句，但是这次使用了 key 为 idx_name_length 的索引。

#### 3.对索引进行表达式计算

![image-20240129154443538](C:\Users\Summerice\AppData\Roaming\Typora\typora-user-images\image-20240129154443538.png)

可以看到 type 仍旧为 ALL，表示走的是全表查询。

原因：

​	与对索引使用函数的原因相同，因为索引中存的是字段原始的值，这样的 SQL 在执行后会先把所有的索引的值拿出来，再依次进行表达式的计算后才进行匹配。

但是：

​	把 SQL 改成![image-20240129154903775](C:\Users\Summerice\AppData\Roaming\Typora\typora-user-images\image-20240129154903775.png)

就会走索引了，因为字段匹配的是一个确定的值。

所以，在日常使用中一定要避免这种情况的发生，因为这是可以通过代码去调整的。

#### 4.对索引进行隐式类型转换

![image-20240129155225284](C:\Users\Summerice\AppData\Roaming\Typora\typora-user-images\image-20240129155225284.png)

可以看到该 SQL 没有走索引。

原因：

​	MySQL 在进行字符串和数字的比较时会**默认把字符串转为数字再进行比较**，而例子中的 name 字段就是字符串，所以在执行 SQL 时会先把 name 的值转为数字，所以该条 SQL 实际执行时是这样的：

```mysql
SELECT * from `user` WHERE CAST(`user`.`name` AS signed int) = 222;
```

所以，这种问题的本质其实是上面刚说过的**2.对索引使用函数**。

#### 5.联合索引非最左匹配

​	首先，对主键创建的索引叫做聚簇索引，对普通字段创建的索引叫二级索引，而还有一种常用的索引是把多个普通字段组合在一起创建索引，这种索引被称作联合索引。

​	联合索引创建和使用时需要注意字段的顺序，因为使用联合索引需要遵循最左匹配原则，也就是从左往右的优先级进行索引匹配。

​	**举例：**假如我们现在创建一个联合索引，值为（a,b,c）

按照最左匹配原则，如果查询条件中缺失了**非最右侧**的字段，则不会走联合索引，比如：

- `where b = 2;`
- `where c = 3;`
- `where b = 2 and c = 3;`

如果是以下几种，则可以走联合索引：

- `where a = 1;`
- `where a = 1 and b = 2;`
- `where a = 1 and b = 2 and c = 3;`
- `where a = 1 and c = 3 and b = 2;` 

​	需要注意的是，在 MySQL 查询优化器的作用下，如果查询条件中的列是**等值查询**，那么他在查询条件中的**顺序不会对查询效率产生明显影响**，如果有多个非等值查询没有按照联合索引字段的顺序来，那么就会对查询效果产生明显的影响。

​	对于 `where a = 1 and c = 3;` 这种情况：

- 在 MySQL 5.5 中，前面的 a 会走索引拿到主键的值然后开始回表，拿到全部数据返回给 Server 层，然后在 Server 层再比较 c 字段的值，最终返回结果。
- 从 MySQL 5.6 之后，新增了**索引下推功能**，即在出现索引截断时，所有的字段都会在存储引擎层进行过滤，等拿到联合过滤后的主键的值后再进行回表操作，这样可以减少回表次数，从而提升查询效率。

特殊的：当整张表所有的字段都为索引时，即使查询时没有遵循最左匹配原则，也是走全扫描二级索引树，类似于上面的**两个字段使用带左模糊匹配的条件查询**

​	综上所述，在一定情况下，不满足最左匹配原则时查询不会走联合索引。

#### 6.WHERE 子句中的 OR 两边不全为索引字段

![image-20240129171226223](C:\Users\Summerice\AppData\Roaming\Typora\typora-user-images\image-20240129171226223.png)

​	我们已知 name 设置了索引而 age 字段没有设置索引，那么在 or 的两边但凡出现一个非索引的字段，另一边字段即使有索引也会失效，而进行全表扫描。

原因：

​	因为 OR 运算符会把两侧的条件分别执行，再将结果合并，所以，只要有一个为非索引字段，那么这个字段的查询就会扫表查询，从而导致整条 SQL 的效率降低。

解决办法：

​	给两边的字段都加上索引。



### 总结：

- 左模糊匹配
- 对索引列使用函数
- 对索引列使用表达式
- 索引列数据类型被隐式转换
- 联合索引查询条件没满足最左匹配
- WHERE 子句中的 OR 两边不全为索引字段